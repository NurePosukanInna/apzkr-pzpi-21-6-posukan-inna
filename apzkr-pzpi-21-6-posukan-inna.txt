Міністерство освіти та науки України
Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук

Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: «Програмна система для автоматичного управління запасами та замовленнями для мережі магазинів»

Студентка гр. ПЗПІ-21-6		 	   Посукан І.І.	
(підпис)
Керівник роботи                                            ______________ ст.викл. Сокорчук І.П.
(підпис)

Роботу захищено   «____» _________ 2024 р. 
з оцінкою  ____________________________
                    ____________________    доц.Лещинський В.О.
(підпис)
		  доц.Лещинська І.О.
(підпис)
		  ст.викл. Сокорчук І.П.
(підпис)

Харків
2024 
                  Харківський національний університет радіоелектроніки

Факультет комп’ютерних наук	Кафедра програмної інженерії	
Спеціальність 121 – Інженерія програмного забезпечення	
Курс	3	Семестр	6	 Навчальна дисципліна  Архітектура програмного забезпечення  	

ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

Посукан Інні Ігорівні
1.	Тема проєкту:  «Програмна система для автоматичного управління запасами та замовленнями для мережі магазинів»___________________________________
2.	Термін узгодження завдання курсової роботи «18»   березня	2024 р.
3.	Термін здачі студентом закінченої роботи « 8 »   червня     2024 р.
4.	Вихідні дані до проєкту:  В програмній системі передбачити створення серверної, клієнтської частини, мобільний застосунок та IoT програмний застосунок. Програмна система монетизована та орієнтована на масову аудиторію. Програмна система підтримує локалізацію та інтернаціоналізацію, забезпечує захист персональних даних. Програмна система підтримує вбудовані засоби адміністрування. Використовувати OC Windows 10, СКБД Microsoft SQL Server 2019, середовище розробки Microsoft Visual Studio 2022, Microsoft Visual Studio Code 2024, Arduino IDE, Android Studio____________________________________
5.	Зміст пояснювальної записки: вступ, аналіз предметної області, постановка задачі, проектування програмного проєкту, структура бази даних. Кодування програмного проекту, опис розробленої програмної частини, висновки, перелік посилань, додатки._____________________________________________________    
6.	Перелік графічного матеріалу: UML-діаграма розгортання , UML-діаграма прецедентів, ER-модель даних, UML-діаграма взаємодії, UML-діаграма діяльності, UML-діаграма компонентів, UML-діаграма станів._________________ 
КАЛЕНДАРНИЙ ПЛАН

№	Назва етапів курсової роботи	Термін виконання	Примітка
1	Функціональна специфікація проєкту	4.04.2024	виконано
2	Проектування програмного проєкту	25.04.2024	виконано
3	Кодування програмного проєкту	19.05.2024	виконано
4	Оформлення пояснювальної записки	30.05.2024	виконано
5	Захист курсової роботи	8.06.2024	виконано

Дата видачі теми проєкту «18» березня   2024 р.


Керівник                                              ___________      ст. викл. Сокорчук І.П.
      (підпис)


Завдання прийняла до виконання
ст.гр. ПЗПІ-21-6	 		Посукан І.І	
(підпис) 





РЕФЕРАТ

Пояснювальна записка до курсового проєктування:  72 с., 1 рис., 1 табл., 5 джерел, 4 додатки.
УПРАВЛІННЯ ЗАПАСАМИ, СКЛАД, ASP.NET.CORE.WEB.API, REACT JS, 
ЗАЯВКА ПОСТАЧАЛЬНИКАМ, ІНТЕРНЕТ РЕЧЕЙ, ІНВЕНТАРИЗАЦІЯ, ОПТИМІЗАЦІЯ ПРОЦЕСІВ, MSSQL, DHT22.
Метою роботи є розробка програмної системи для автоматичного управління запасами та замовленнями для мережі магазинів.
Результатом розробки стала програмна система «Inventory», яка дозволяє автоматизувати різноманітні процеси в торгівлі та управлінні замовленнями постачальникам.



 
ЗМІСТ


ВСТУП ……………………………………………………………………. .6
1.	АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ ТА ПОСТАНОВКА ЗАДАЧІ…..7
1.1	 Загальний опис проблеми….……………………..………….…….7
1.2	 Аналіз аналогів…………..………………...……………………….7
1.3	 Концептуальне моделювання предметної області ………..……..8
1.4	 Постановка задачі…………………………………………………..8
2.	ПРОЕКТУВАННЯ БАЗИ ДАНИХ……………………………...……..12
2.1	 Побудова ER-діаграми……………………………………………..12
2.2	 Вибір та побудова логічної моделі бази даних на основі ER-діаграми…………………………..……………...……………….....13
2.3	Технології розробки бази даних…………………………………...13
3.	ВЗАЄМОДІЯ МІЖ ЧАСТИНАМИ ПРОГРАМНОЇ СИСТЕМИ…....15
3.1 Опис взаємодії між частинами програмної системи……………..15
4.	ПРОЄКТУВАННЯ СЕРВЕРНОЇ ЧАСТИНИ………………………….16
4.1	 Технології розробки серверної частини……….……………...….16
4.2	 Архітектура серверної частини…………………………………...17
4.3	 Структура серверної частини……………………………………..17
4.4	 Безпека проєкту……………………………………..………….….18
4.5	 Специфікація REST API…………………………………………..18
4.6	 Опис задачі автоматизації………………………………………...22
5.	ПРОЄКТУВАННЯ КЛІЄНТСЬКОЇ ЧАСТИНИ……………………..24
5.1	 Технології розробки клієнтської частини………………………..24
5.2	 Архітектура клієнтського застосунку…………………………….25
5.3	 Структура клієнтського застосунку……………………...…….…25
5.4	 Обробка запитів з серверної частини…………………………….25
5.5	 Взаємодія користувача з системою…………………………………..26
6.	ПРОЄКТУВАННЯ IoT ЧАСТИНИ………………………………………28
6.2	Технології розробки IoT частини……………………………………..28
6.2 Архітектура IoT частини……………………………………………...28
6.3	Взаємодія користувача з пристроєм IoT ……………………………..28
6.4	 Відправлення даних на сервер з IoT пристрою……………………...28
7.	ПРОЄКТУВАННЯ МОБІЛЬНОЇ ЧАСТИНИ……………………………29
7.1 Технології розробки мобільної частини……………………………...29
7.2 Архітектура мобільної частини……………………………………….29
7.3 Структура мобільної частини…………………………………………29
7.4 Взаємодія користувача з системою…………………………………..30
8.	ТЕСТУВАННЯ ПРОГРАМНОГО ЗАСТОСУНКУ……………………...31
8.1	 Вибір методу тестування……………………………………………...31
8.2	 Огляд розробленої клієнт-серверної частини веб-додатку…………31
8.3	 Огляд взаємодії IoT пристрою з клієнт-серверною частиною додатку…………………………………………………………………..34
8.4	 Огляд взаємодії мобільного пристрою з серверною частиною додатку…………………………………………………………………..34
ВИСНОВКИ…………………………………………………………………....36
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ………………………..……....................37
ДОДАТОК А – ДІАГРАМИ…………………………………......……………38
ДОДАТОК Б – КОД ПРОГРАМИ………………...………...………..……….48
ДОДАТОК В – ІНТЕРФЕЙСИ ПРОГРАМИ………………………………...50
ДОДАТОК  Г – ПЕРЕВІРКА НА ПЛАГІАТ…………………………………73


ВСТУП


Ефективне управління запасами та замовленнями має вирішальне значення для успіху будь-якої роздрібної мережі. Сучасні методи управління дозволяють не тільки забезпечити безперебійне постачання товарів, але й оптимізувати витрати на їх зберігання та логістику, що безпосередньо впливає на конкурентоспроможність і прибутковість підприємства. 
Зростаючі вимоги до управління запасами зумовлені постійними змінами на ринку та необхідністю впровадження передових технологій і методів для автоматизації процесів ланцюга поставок. Особлива увага приділяється методам прогнозування попиту та управління ланцюгом поставок, які знижують ризик надлишку або недостатності запасів. 
Метою даного дослідження є розробка та впровадження ефективної системи управління товарними запасами та замовленнями торговельної мережі з метою оптимізації процесів поставки та покращення управління продукцією.
Для досягнення цієї мети було розроблено програмну систему, яка автоматично прогнозує попит на товари та відправляє замовлення постачальникам.
 
1 АНАЛІЗ ПРЕДМЕТНОЇ ОБЛАСТІ ТА ПОСТАНОВКА ЗАДАЧІ


1.1	Загальний опис проблеми

У сучасному світі ефективне управління запасами є невід'ємною частиною успішної роботи будь-якої роздрібної мережі. Зростання обсягів продажів призводить до необхідності автоматизації процесів замовлення товарів у постачальників та оптимального управління запасами. 
Наразі багато мереж продуктових магазинів все ще використовують ручне формування замовлень на закупівлю, що вимагає значних зусиль від працівників магазинів. Такий підхід має кілька суттєвих недоліків: високі часові витрати, ризик помилок через людський фактор та недостатня ефективність. Працівники витрачають значну кількість робочого часу на підготовку та оформлення замовлень, а ручне формування замовлень не дозволяє швидко реагувати на зміни попиту, що може призвести до дефіциту або надлишку товарів.
 Наш проект спрямований на створення програмного продукту, який автоматизує цей процес шляхом аналізу потреб магазину та формування замовлень постачальникам. Такий підхід допоможе заощадити час та зменшити ймовірність людської помилки. 

1.2	Аналіз аналогів 

Ринок торгівлі активно розвивається, що змушує підприємства постійно вдосконалювати та автоматизувати свої бізнес-процеси. Зміни споживчих уподобань, стрімкий розвиток технологій і постійна конкуренція змушують компанії пропонувати нові технології для залучення користувачів. Щоб зрозуміти структуру ринку, аналіз конкурентів показав, що SAP ERP і Zoho Inventory виділяються серед лідерів у  даній галузі.
SAP ERP — це інтегрована система управління ресурсами підприємства, яка включає функції фінансового обліку, управління закупівлями, аналітику та звітність і забезпечує повний контроль над бізнесом. Ця система особливо ефективна для великих компаній зі складною структурою, але має недолік — високі витрати на впровадження та обслуговування. Крім того, новачкам це може бути важко через велику кількість модулів і функцій, призначених для управління різними сферами бізнесу.
Zoho Inventory, з іншого боку, спеціалізується на управлінні запасами та складському обліку та пропонує просте програмне забезпечення, яке ідеально підходить для малого бізнесу з обмеженим бюджетом. На відміну від SAP ERP, система Zoho є хмарним рішенням, тому вона залежить від підключення до Інтернету. Це може призвести до недоступності даних і проблем з продуктивністю, коли немає Інтернету.
Отже, проблема, яку ми бачимо в сучасних аналогах, полягає в недостатньому балансі між функціональністю та доступністю для користувачів. Наш продукт буде конкурентоспроможним завдяки здатності пропонувати просте та ефективне керування продуктом, яке буде зрозуміле як новачкам, так і досвідченим користувачам.

1.3	Концептуальне моделювання предметної області 

Розглянемо функціональне призначення програмної системи для управління замовленнями та запасами. Для цього побудуємо загальну Use-Case діаграму функцій програми (див.рис.А.1).
З даної діаграми можна побачити що, у системі існують два типи користувачів: касир і власник магазину. Власник магазину може придбати підписку, яка надає йому доступ до таких дій, як керування магазинами, продуктами, працівникам. Він також може переглядати інформацію про продані товари. Касир може продавати товари зі складу, приймати поставки та перевіряти правильність замовлень, сформованих системою. 
Крім цього, власник магазину може взаємодіяти з IoT пристроєм. Їх взаємодія наведена на Use-Case діаграмі (див.рис.А.2).
Додатково, у мобільній версії програмного додатку власник магазину може користуватися мобільним пристроєм для виконання функцій, що представлені на Use-Case діаграмі (див. рис. А.3).
	Проаналізувавши предметну область виділимо наступні концепти: 
a)	Концепт «Власник» має такі властивості:
1)	прізвище;
2)	ім’я;
3)	електронна пошта;
4)	пароль;
5)	номер телефону;
b)	Концепт «Робітник» має такі властивості:
1)	прізвище; 
2)	ім’я;
3)	електронна пошта;
4)	пароль;
5)	посада;
c)	Концепт «Магазин» має такі властивості:
1)	назва магазину;
2)	адреса;
d)	Концепт «Продукт» має такі властивості:
1)	назва продукту;
2)	ціна;
3)	валюта;
4)	об’єм;
5)	одиниці виміру;
6)	дата зберігання;
e)	Концепт «Постачальник» має такі властивості:
1)	назва постачальника;
2)	номер телефону;
3)	адреса;
f)	Концепт «Заявка постачальнику» має такі властивості:
1)	кількість;
2)	загальна сума;
3)	дата формування заявки;
4)	статус;
5)	дата доставки;
Дані концепти формують базовий опис предметної області та визначають основні сутності , які будуть використовуватися в програмній системі для управління запасами та замовленнями.

1.4	Постановка задачі

Мета курсового проекту полягає в створенні комплексної системи, що складається з чотирьох основних компонентів: серверної, клієнтської, IoT та мобільної версій. Окрім цього, потрібно розробити базу даних, яка відповідатиме потребам предметної області. 
Програмна система має надавати різні функції для двох типів користувачів: власника та касира.
Власник має такі функції: 
-	авторизація та реєстрація;
-	оформлення підписки;
-	керування персоналом магазину;
-	управління магазинами та  асортиментом товарів;
-	моніторинг запасів;
-	керування замовленнями постачальникам;
-	аналіз продажів;
-	створення резервної копії даних;
Касир має такі функції:
-	продаж товарів;
-	перегляд історії продажів;
-	приймання товарів від постачальника;
Отже, програмна система повинна надати функції для зручного керування бізнесом та забезпечити ефективне обслуговування клієнтів.



 
2	ПРОЄКТУВАННЯ БАЗИ ДАНИХ


2.1	 Побудова ER-діаграми бази даних

Для візуалізації структури бази даних та визначення сутностей створимо ER-діаграму (див.рис.А.4). Розглянемо зв`язки між кожною парою сутностей. 
Між сутностями “user” та “subscription” існує зв'язок типу один до багатьох, оскільки кожен користувач може мати багато підписок. 
Між сутностями "user" та "store" існує зв'язок один до багатьох, оскільки кожен користувач може створити багато магазинів в системі.
Між сутностями “subscription” та “subscription_type”  також існує зв'язок типу один до багатьох, оскільки кожна підписка пов'язана з одним типом підписки, проте один тип підписки може мати багато підписок. 
Між сутностями “store” та “product” існує зв'язок багато до багатьох, оскільки кожен магазин може мати багато продуктів, а також кожен продукт може бути доступним в багатьох магазинах. Для цього створюється проміжна таблиця “store_product”. 
Між сутностями “product” та “category” існує зв'язок один до багатьох, оскільки один продукт може належати лише до однієї категорії, проте кожна категорія може мати багато продуктів. 
Між сутностями “product” та “supplier” існує зв'язок один до багатьох, оскільки кожен продукт може мати багато постачальників, але кожен постачальник може постачати багато продуктів.
 Між сутностями “product” та “defective_product” існує зв'язок один до багатьох, оскільки кожен продукт може мати багато зіпсованих варіантів. 
Між сутностями “supplier_request” та “product” також існує зв'язок один до багатьох, оскільки кожен запит від постачальника може включати багато продуктів. 
Між сутностями “sale” та “employee” існує зв'язок один до багатьох, оскільки кожен продаж здійснюється лише одним працівником, але кожен працівник може мати багато продажів. 
Між сутностями “sale” та “store” існує зв'язок один до багатьох, оскільки кожен продаж відбувається в конкретному магазині, проте кожен магазин може мати багато продажів. 
Між сутностями “sale” та “product” існує зв'язок багато до багатьох, оскільки кожен продаж включає в себе багато продуктів, і навпаки, кожен продукт може бути частиною багатьох продажів. Для цього створюється проміжна таблиця “sale_products”. 
Між сутностями “sensor” та “store” існує зв'язок один до багатьох, оскільки кожен датчик може бути пов'язаний лише з одним магазином, але кожен магазин може мати багато датчиків.

2.2	Вибір та побудова логічної моделі бази даних на основі ER-діаграми

Для проєктування системи було обрано реляційну модель бази даних, оскільки вона дозволяє організувати дані у вигляді таблиць з рядками та колонками, що спрощує процес зберігання. Крім того, ця модель дозволяє легко встановлювати зв'язки між таблицями, що полегшує управління інформацією.
Побудуємо логічну модель бази даних, шляхом звернення до ER-діаграми (див.рис.А.5).



2.3	Технології розробки бази даних

У даному проєкті буде використано базу даних Microsoft SQL Server, оскільки вона широко використовується у програмній розробці на платформі .NET. 
Крім того, ця база даних пропонує значний функціональний набір, включаючи ефективне керування даними та високий рівень безпеки. 
Для управління цією базою даних буде використано Microsoft Management Studio 2018.
 
3	ВЗАЄМОДІЯ МІЖ ЧАСТИНАМИ ПРОГРАМНОЇ СИСТЕМИ


3.1	Опис взаємодії між частинами програмної системи

Програмна система складається з чотирьох компонентів, які мають взаємодіяти між собою та бути синхронізованими. Для досягнення цих цілей було реалізовано наступну взаємодію (див.рис.3.1)

 
Рисунок 3.1 – загальна діаграма компонентів

З діаграми, можна побачити що серверна частина взаємодіє з клієнтською та IoT частиною за допомогою HTTP-запитів. Серверна частина встановлює зв’язок з базою даних за допомогою TCP/IP через порт 7074. Мобільна частина використовує драйвер JTDS для підключення до тієї ж бази даних, що й серверна частина.
 
4	ПРОЄКТУВАННЯ СЕРВЕРНОЇ ЧАСТИНИ


4.1	Технології розробки серверної частини

Для розробки серверної частини було обрано платформу .NET в поєднанні з технологієї ASP.NET Core Web API та мови програмування C#. 
.NET - це середовище, що надає можливості для розробки та виконання програмного забезпечення з відкритим вихідним кодом.
ASP.NET Core Web API – це технологія, яка дозволяє розробляти Restful веб-сервіси за допомогою платформи .NET. Вона надає зручний спосіб створення API для взаємодії з клієнтськими застосунками.
ASP.NET Core Web API має кілька переваг: 
-	працює на різних операційних системах (Windows, Linux та macOS);
-	ефективна обробка великого обсягу запитів;
-	підтримує різні методи автентифікації , такі як JWT;
-	забезпечує використання патерну MVC (Model-View-Controller);
Для взаємодії з базою даних було обрано ORM Entity Framework Core, що дозволяє полегшити завдання розробникам  в роботі з базою даних. Для цього потрібно встановити пакет Microsoft.EntityFrameworkCore.SqlServer.
Переваги цього ORM включають:
-	зручне зберігання, читання, зміна та видалення даних без прямої роботи з SQL запитами;
-	підтримка асинхронної роботи;
-	використання LINQ запитів для доступу у вигляді об’єктів;
-	механізм міграцій, що спрощує процес зміни схеми бази даних, а також дозволяє зберігати структуру бази актуальною без зайвих зусиль;
4.2	Архітектура серверної частини

Програмна система побудована на основі клієнт-серверної архітектури, що передбачає поділ на дві основні частини: клієнтську та серверну. Також, у серверній частині програмного застосунку використовується патерн проектування MVC (Model-View-Controller). Цей шаблон дозволяє розділити логіку на три компоненти: модель, що представляє дані та бізнес-логіку програми; контролер, який керує взаємодією між моделлю та представленням; і представлення, яке відображає інформацію користувачеві. У нашому випадку за представлення відповідає фреймворк React JS.

4.3	Структура серверної частини

Через те, що серверна частина використовує ORM Entity Framework Core для взаємодії з базою даних, структура проекту буде організована наступним чином: 
-	папка Controllers містить контролери, які обробляють HTTP-запити і взаємодіють з моделями та сервісами;
-	папка Data зберігає контекст бази даних та ініціалізує з'єднання з базою даних;
-	папка DTO (Data Transfer Objects) містить об'єкти передачі даних, які використовуються для передачі даних між клієнтом і сервером;
-	папка Interfaces зберігає інтерфейси для сервісів;
-	папка Migrations містить файли міграцій для управління змінами у структурі бази даних;
-	папка Models містить моделі даних, які відображають структуру таблиць у базі даних;
-	папка Services організовує бізнес-логіку додатка, обробляючи основні операції і взаємодію з моделями;
-	папка Tools містить інструменти для хешування паролю;
-	Appsettings.json файл конфігурації додатка, містить налаштування з'єднання з базою даних та інші конфігураційні параметри;
-	Program.cs файл, який ініціалізує та запускає веб-додаток;
Ця структура сприяє легкому управлінню кодом та підтримці додатка.

4.4	Безпека проєкту

В системі забезпечено безпеку даних користувачів за допомогою двох шарів захисту: JWT (JSON Web Token) для шифрування та підпису і хешування паролів з використанням SHA-256. При виклику методу hashPassword, він приймає строку паролю, перетворює її в байтовий масив, обчислює хеш, і повертає закодований пароль у вигляді рядка з використанням Base64 (див. Додаток В розділ В.1).

4.5	Специфікація REST API

Додаток надає широкий набір можливостей через REST API для ефективного керування торговими процесами та взаємодії різних користувачів у системі. Нижче наведено специфікацію основних методів API та їх призначення (див. табл. 1).

   	Таблиця 1. – Специфікація проєкту
Сутність	Метод	Посилання	Дія
User	POST	/api/User/Register	Реєстрація користувача в системі
		/api/User/Login	Вхід в систему
	GET	/api/User	Отримання всіх користувачів в системі
Employee	POST	/api/Employee	Додавання працівника в систему
	DELETE	/api/Employee /{id}	Видалення користувача з системи
	PUT	/api/Employee /Employee{id}	Оновлення даних про працівника
	GET	/api/Employee /{id}/stores	Отримання магазинів, які доступні тільки для конкретного працівника
Store	POST	/api/Store	Створення магазину
	GET	/api/Store/{userId}	Отримання магазинів створених власником
	PUT	/api/Store/{storeId}	Оновлення інформації про магазини
Subscription	POST	/api/Subscription/{userId}	Оформлення підписки
		/api/Subscription/addType	Створення типів підписки
	GET	/api/Subscription	Отримання всіх підписок в системі
		/api/Subscription/{userId}
Отримання активної підписки для конкретного користувача
Product	POST	/api/Product	Додавання товару в систему
	DELETE	/api/Product/{productId}	Видалення продукту
	GET	/api/Product/ {storeId}	Отримання продуктів для конкретного магазину
	PUT	/api/Product/{productId}	Оновлення інформації про продукт
Defective Products	GET	/api/DefectiveProducts/{storeId}	Отримання зіпсованих товарів для конкретного магазину
Sale 	POST	/api/Sale	Продаж товару
	GET	/api/Sale/{storeId}	Отримання інформації про продаж товарів для конкретного магазину
Supplier	POST	/api/Supplier	Додавання постачальника
	GET	/api/Supplier	Отримання постачальників
	DELETE	/api/Supplier/{id}
Видалення постачальника
Supplier Request	GET	/api/SupplierRequest/{userId}	Отримати сформовані заявки для конкретного користувача
	PUT	/api/SupplierRequest{id}	Оновлення даних про заявку
	DELETE	/api/SupplierRequest{id}	Видалення заявки
Category	POST	/api/Category	Додавання категорій
	GET	/api/Category	Отримання категорій
		/api/Category/{categoryId}	Фільтрація товарів по категоріям
	DELETE	/api/Category/{categoryId}	Видалення категорії
Sensor	POST	/api/Sensor	Додавання сенсору
	GET	/api/Sensor	Отримання значень сенсору
	PUT	/api/Sensor/{sensorId}	Оновлення значень сенсору
	DELETE	/api/Sensor/{sensorId}	Видалення сенсору
Backup	GET	/api/Backup/CreateBackup	Створення резервної копії користувацьких даних

Таким чином, ця специфікація показує основні методи REST API для програми, яка забезпечує ефективне управління торговими процесами в мережі продуктових магазинів.

4.6	Опис задачі автоматизації

Задача автоматизації полягає в автоматичному аналізі залишків товарів на складі та формуванні замовлень у разі недостатньої кількості. Якщо товарів на складі менше ніж мінімальна кількість, система формує замовлення постачальнику. Кількість товарів для замовлення визначається наступним чином: якщо раніше не було замовлень на цей товар, кількість замовлених товарів дорівнює різниці між мінімальною кількістю та поточною кількістю на складі. Якщо є хоча б два попередні замовлення на цей товар, кількість замовлених товарів визначається як середнє арифметичне між цими замовленнями, помножене на коефіцієнт 1.2 (див. Додаток В розділ В.2).
 Таким чином, система автоматично підтримує оптимальний запас товарів на складі.
 
5	ПРОЄКТУВАННЯ КЛІЄНТСЬКОЇ ЧАСТИНИ


5.1	Технології розробки клієнтської частини

В якості технології для розробки клієнтської частини був використаний фреймворк React JS. React базується на компонентах багаторазового використання та використовує JSX, синтаксис XML, який поєднує JavaScript і HTML.
Даний фреймворк має наступні переваги:
-	використання віртуального DOM (Document Object Model), для ефективного оновлення веб-сторінок;
-	повторне використання компонентів;
-	односпрямований потік даних;
Також, для обробки HTTP-запитів використовується бібліотека axios. Вона дозволяє легко відправляти запит до серверу та отримувати відповіді.
Для підтримки стилів використовувалась бібліотека Bootstrap 5. Вона надає готові компоненти для створення дизайну  в програмному застосунку.

5.2	Архітектура клієнтського застосунку

У клієнтській частині програмного застосунку використовується класична компонентна архітектура. Згідно з цією архітектурою, додаток розбивається на набір компонентів, які можна повторно використовувати. Кожен компонент відповідає за свою логіку або частину інтерфейсу.


5.3	Структура клієнтського застосунку

У клієнтській частині програмного застосунку структура організована наступним чином: 
-	папка components містить різні компоненти, такі як menu, language switcher та sales chart;
-	папка pages містить різні сторінки системи;
-	папка http використовується для взаємодії з сервером, зокрема для отримання даних або їх відправлення;
-	у папці styles знаходяться файли CSS, які відповідають за оформлення сторінок;
-	папка assets містить зображення, які використовуються в програмному застосунку;
-	файли App.js і index.js є кореневими файлами компонента і точками входу для відображення застосунку;
Дана структура дозволяє легко організувати та керувати сторінками, стилями та іншими ресурсами системи в проєкті. Для більш детального розуміння структури проєкту була створена діаграма компонентів (див.рис.А.6).

5.4	Обробка запитів з серверної частини

Як вже було зазначено раніше, обробка запитів з серверної частини здійснюється за допомогою бібліотеки axios. Для прикладу візьмемо запит для реєстрації користувача в системі (див. Додаток В розділ В.3). В даному фрагменті виконується POST-запит до серверу за відповідним маршрутом. При отриманні цього запиту,  сервер обробляє передані дані, створює запис про користувача у базі даних та надсилає відповідь на клієнт.
Такий підхід дозволяє забезпечити ефективну взаємодію між клієнт-серверним додатком

5.5	Взаємодія користувача з системою 

Для детального розуміння взаємодії користувача з системою представлена діаграма станів (див.рис.А.7), що описує процес авторизації та реєстрації , а також їхні дії після успішного входу в систему.
Спочатку користувач знаходиться у стані "Незареєстрований". Якщо він вирішує створити новий обліковий запис, він натискає кнопку "Зареєструватися", що переводить його до стану "Реєстрація". Тут він вводить свої дані електронної пошти та пароль. Якщо введені дані недійсні, він залишається у стані "Реєстрація" та отримує повідомлення про помилку. У разі правильних даних користувач переходить до стану "Головна сторінка".
На головній сторінці користувач має можливість перейти до розділу "Підписки". Тут він може обрати та придбати підписку. Якщо обрана підписка є преміум-підпискою, користувач отримає доступ до сторінок магазину, продукції, персоналу, замовлень та аналітики. У випадку, якщо вибрана підписка є стандартною, користувачу будуть доступні всі функції, за винятком аналітики.
Таким чином, діаграма станів відображає всі можливі дії користувача на різних етапах взаємодії з веб-сайтом, починаючи з реєстрації та закінчуючи управлінням замовленнями.


6	ПРОЄКТУВАННЯ IoT ЧАСТИНИ


6.1	Технології розробки IoT частини

Для розробки IoT-частини використовувався емулятор Wokwi. В проєкті міститься мікроконтролер ESP32 для надсилання даних на сервер. Він також включає датчик DHT22 для вимірювання температури та вологості в приміщенні, дисплей з інтерфейсом I2C для ручного відображення температури в приміщенні, а також світлодіодну лампу, яка сповіщає власника про те, що температура або вологість відхиляються від норми.

6.2	Архітектура IoT частини 

Перша складова архітектури включає в себе об'єкти, що мають доступ до Інтернету та можуть збирати дані з навколишнього середовища. Наступним етапом є система збору даних Інтернету речей (IoT) та використання шлюзів для їх передачі. Третій рівень охоплює візуалізацію зібраних даних. Після цього дані передаються на локальний сервер та зберігаються там для подальшого використання в конкретному магазині.

6.3	Взаємодія користувача з пристроєм IoT 

Спочатку, промоделюємо послідовність процесів в системі (див.рис.А.8). З діаграми активності видно, що спочатку датчик активується і починає збирати дані про температуру та вологість. Потім відбувається перевірка цих параметрів, щоб переконатися, що вони знаходяться в допустимому діапазоні. Після цього датчик підключається до мережі і передає отримані дані на сервер. Якщо параметри температури та вологості відрізняються від норми, датчик автоматично надсилає повідомлення на електронну пошту користувача.
Також, розглянемо взаємодію користувача з IoT пристроєм. Для цього створимо діаграму взаємодії (див. рис. А.9),  яка демонструє процес вимірювання температури на складі за допомогою датчика вологості та температури.
З діаграми видно, що спочатку пристрій намагається під єднатися до мережі, після чого зчитує дані з сенсорів та відправляє на сервер. Якщо дані успішно відправились відображається позитивний статус, в іншому випадку негативний.

6.4	Відправлення даних на сервер з IoT пристрою

Розглянемо, як саме дані відправляються на сервер за допомогою HTTP-запиту (див. Додаток В розділ В.4). Спочатку створюється об'єкт HttpClient та викликається метод begin(). Після цього додається заголовок і викликається метод put() з параметром jsonStr, який містить дані про температуру та вологість у форматі JSON. Після виклику put() перевіряється HTTP-відповідь: якщо httpResponseCode більше 0, це означає успішну відповідь від сервера, і виводиться HTTP-код відповіді. У протилежному випадку виводиться код помилки.


7	ПРОЄКТУВАННЯ МОБІЛЬНОЇ ЧАСТИНИ


7.1	Технології розробки мобільної частини

В якості технології розробки мобільної частини була обрана середа розробки Android Studio з мовою програмування Kotlin. Для взаємодії з базою даних використовується бібліотека jTDS, яка забезпечує підтримку підключення до Microsoft SQL Server на платформі Android.

7.2	Архітектура мобільної частини

У мобільному застосунку використовується архітектурний підхід MVP (Model-View-Presenter), який дозволяє чітко розділити бізнес-логіку від представлення даних та управління користувачем через інтерфейс.

7.3	Структура мобільної частини

У мобільній частині структура розділена на такі складові:  
-	папка  Data містить в собі представлення інформації про продукт, запит, магазин;
-	папка Services містить бізнес логіку додатку;
-	Fragment та Activity відповідають за відображення користувацького інтерфейсу;
-	У папці ресурсів зберігаються макети користувацького інтерфейсу, векторні зображення та меню, що використані в мобільному додатку;
Дана структура дозволяє ефективно управляти розробкою, тестуванням та розширенням функціональності.
7.4	Взаємодія користувача з системою

Розглянемо послідовність дій, які потрібно виконати користувачеві для входу в систему через мобільний додаток (див.рис.А.10). Користувач має можливість переглядати інформацію про магазини, включаючи їх назви, адреси та дані з датчиків (такі як температура, вологість), а також робити запити на замовлення у постачальників. Крім того, він може переглядати свій профіль, який містить особисту інформацію, та оновлювати дані. Показники з датчиків автоматично оновлюються системою, і якщо вони виходять за межі нормальних значень, користувач отримує повідомлення про потенційні проблеми, наприклад, високу або низьку температуру чи вологість на складі.
Також,наведемо діагрмау станів для візуалізаціх сианів через які прроходить користувач в ході роботи з застосунком (див.рис.А.11). 
Як видно з діаграми , користувач взаємодіє з сайтом, починаючи зі сторінки входу. Після успішного введення даних він стає "Авторизованим користувачем" і автоматично переходить на головну сторінку, де доступні всі функції мобільного додатку. 
З головної сторінки можна переглядати магазини, запити та профіль. Якщо користувач бажає оновити інформацію про конкретний продукт чи запит, він виконує дію "Оновлення інформації" на відповідній сторінці. 
Також на сторінці профілю можна переглянути або оновити свої дані. У будь-який момент користувач може вийти з системи, виконавши відповідну дію “Вийти".
 
8	ТЕСТУВАННЯ ПРОГРАМНОЇ СИСТЕМИ


8.1	Вибір методу тестування

Тестування даного програмного продукту проводилось за методикою «сірої скриньки». Цей метод передбачає тестування системи з точки зору користувача без доступу до детальної документації або внутрішньої реалізації програми. Такий підхід дозволяє виявити проблеми, які виникають через неправильне використання системи або неочевидну поведінку, що в свою чергу допомагає покращити функціональність. 
Об'єктом тестування є програмна система управління запасами та замовленнями для мережі продуктових магазинів. 
Метою тестування є виявлення помилок у інтерфейсі та функціональних недоліків.
Всі частини системи, включаючи серверну, клієнтську, мобільну та IoT-версії, будуть протестовані для забезпечення їх сумісності та оптимальної продуктивності.

8.2	Огляд розробленої клієнт-серверної частини веб-додатку

Для початку роботи з додатком, потрібно його запустити. Після запуску користувач побачить сторінку входу в систему. Якщо користувач не має облікового запису, він може перейти на сторінку реєстрації та зареєструватися в системі. Після реєстрації користувач отримає повідомлення про успішну реєстрацію (див. рис. Г.1- Г.2).
Завершивши реєстрацію, користувач може увійти в систему, використовуючи свої облікові дані. Для цього необхідно натиснути на посилання «Вже маєте обліковий запис?» на сторінці реєстрації та заповнити поля електронної пошти та пароля. Якщо введені дані валідні, користувач отримає повідомлення про успішний вхід у систему (див. рис. Г.3 – Г.4). 
Після успішного входу користувач побачить головне меню та панель управління, де також буде доступна вкладка «Підписки» (див. рис. Г.5). Натиснувши на вкладку «Підписки» (див. рис. Г.6), користувач зможе обрати один з двох типів підписок: преміум або стандарт. Спочатку придбаємо преміум-підписку. Як тільки підписка успішно оформлена, користувач буде автоматично направлений на сторінку активної підписки, де він зможе побачити всі деталі своєї підписки (див.рис.Г.7). 
Далі за допомогою меню користувач може перейти на сторінку магазинів і додати новий магазин в програмну систему (див. рис. Г.8). Після додавання магазину переглянемо інформацію про нього (див. рис. Г.9).
Наступним кроком буде додавання товару до цього магазину (див. рис. Г.10). Після додавання, переглянемо деталі цього товару в списку товарів в магазині (див. рис. Г.11). Користувач також може оновити інформацію про товар, наприклад, змінити ціну, назву, категорію та інше. (див. рис. Г.12).
Якщо продукт має закінчений термін придатності, він буде автоматично переміщений до таблиці зіпсованих товарів (див. рис. Г.13). Це гарантує, що прострочені товари не будуть продані.
Для тестування пошуку товарів у системі попередньо було додано ще один товар (див. рис. Г.14). Виконаємо пошук за назвою товару, щоб переконатися, що функція пошуку працює коректно (див. рис. Г.15).
Перейдемо на вкладку «Співробітники» через меню та додамо касира в систему (див. рис. Г.16). Після додавання касира переглянемо його наявність в списку співробітників (див. рис. Г.17). У системі також є можливість оновлювати дані про співробітника, наприклад, змінювати його контактну інформацію, посаду та інше (див. рис. Г.18).
Щоб перевірити роботу системи під різними ролями, увійдемо в систему як касир (див. рис. Г.19). Касир має обмежений функціонал, тому меню для нього виглядає інакше (див. рис. Г.20). Спочатку відкриємо список магазинів, до яких має доступ касир (див. рис. Г.21), а потім перейдемо на сторінку товару в обраному магазині. Після цього, натиснувши на відповідний товар, ми можемо його продати. Обов’язково потрібно вказати кількість товарів, для продажу (див. рис. Г.22). Далі можна переглянути інформацію про здійснені продажі (див. рис Г.23).
Після здійснення продажі, кількість проданих товарів віднімається від загальної кількості (див. рис. Г.24). Оскільки, кількість товарів на складі стає меншою за мінімальну,  то заявка на продукцію автоматично формується постачальнику (див. рис. Г.25). Після прибуття товару від постачальника, статус замовлення встановляється  «Виконаний», та вказується дата доставки (див. рис. Г.26). Перевіримо, що статус замовлення дійсно змінився (див. рис. Г.27). Повернувшись на сторінку товарів, можна побачити, що загальна кількість знову збільшилася (див. рис. Г.28).
Система, також, автоматично визначає яку кількість товарів вказати в замовленні постачальнику. Якщо на цей товар не було попередніх замовлень, кількість на складі віднімається від мінімальної кількості (див. рис. Г.24 – Г.25). В іншому випадку, якщо було щонайменше два замовлення, система аналізує історичні дані і обчислює середнє арифметичне між ними, яке потім множиться на коефіцієнт 1,2 для визначення попиту (див. рис. Г.29).
Далі, вийдемо з облікового запису касира і знову ввійдемо під своїм обліковим записом. Перейдемо на вкладку аналітики, де на діаграмі для магазину «ProductShop» бачимо, що 10.06.2024 було продано 41 одиницю товару (див. рис. Г.30).
Також, в системі доступна функція локалізації. Для цього змінимо мову з англійської на українську та переглянемо декілька сторінок, щоб переконатися у правильній роботі цієї функції (див. рис. Г.31-Г.32). 
Після цього створимо ще один обліковий запис і придбаємо стандартну підписку. З цією підпискою користувач матиме доступ до всіх функцій, окрім аналітики (див. рис. Г.33).

8.3	Огляд взаємодії IoT пристрою з клієнт-серверною частиною додатку

У наші програмній системі нормальний діапазон температури визначається як 17-22 градуси за Цельсієм, а нормальний діапазон вологості - від 40% до 60%.
Внесемо зміни у значення температури, що виходить за межі норми, і відправимо ці дані на сервер (див. рис. Г.34-Г.35).
Так як, значення низькі , то користувач отримає повідомлення на пошту про відхилення температури від заданого діапазону (див. рис. Г.36).

8.4	Огляд взаємодії мобільного пристрою з серверною частиною додатку

Увійдемо в систему за допомогою того ж облікового запису, який ми використовували для входу на сайт. Для цього, потрібно заповнити поля електронної пошти та пароля (див. рис. Г.37). Після успішного входу користувач може бачити магазини, які вже були додані цим обліковим записом (див. рис. Г.38).
Оскільки температура становить 6,8 градусів за Цельсієм, що менше ніж нормальний діапазон, на телефон буде надіслано повідомлення про критичний рівень температури на складі (див. рис. Г.39).
Натиснемо на магазин та перейдемо на вкладку товарів (див. рис. Г.40). Тут можна побачити, що товари також синхронізувалися та доступна їхня назва та категорія. Після цього, натиснемо на конкретний продукт і відкриється детальна інформація про нього з можливістю зміни інформації (див. рис. Г.41).
Далі, за допомогою нижнього меню перейдемо на вкладку "Запити постачальнику" (див. рис. Г.42). Натиснемо на конкретний запит і побачимо детальну інформацію про нього та поля для змін. Змінимо статус замовлення на "Виконаний", натиснувши на кнопку "Оновити" (див. рис. Г.43). Після цього перевіримо, що запит оновився (див. рис. Г.44 – Г.45).
Далі, відкриємо профіль користувача (див. рис. Г.46). Змінимо дані про ім'я, прізвище та номер телефону, а потім перевіримо виконання змін (див. рис. Г.47).
На сторінці профілю також є кнопка виходу з системи. При натисканні на неї користувач повернеться на сторінку входу.
 
ВИСНОВКИ

Під час виконання цієї курсової роботи була створена комплексна програмна система, яка включає в себе синхронізацію між всіма її компонентами. Ця система призначена для ефективного управління запасами та замовленнями в мережі продуктових магазинів.
Система складається з чотирьох ключових компонентів: серверної, клієнтської, мобільної та IoT частин, кожна з яких відповідає за певний функціонал і забезпечує зручний доступ та ефективну взаємодію з системою для різних категорій користувачів.
Функціонал розроблений відповідно до вимог і потреб користувачів, дозволяючи їм виконувати широкий спектр операцій, включаючи управління персоналом, замовленнями, магазинами та продуктами.
В результаті виконання курсового проекту отримано працездатний програмний продукт, який можна впровадити в роздрібну торгівлю.
Крім того, планується подальший розвиток системи, включаючи вдосконалення функціональності, зовнішнього вигляду та інтеграцію з іншими сервісами.
 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ

1.	Мартін Р. Чистий код: створення, аналіз та архітектура – Харків: Фабула, 2019. – 200 с.
2.	React JS Documentation. URL: https://legacy.reactjs.org/docs/getting-started.html (дата звернення 11.05.2024)
3.	.NET Documentation. URL: https://learn.microsoft.com/en-us/dotnet/ (дата звернення (дата звернення 18.04.2024)
4.	Демо функціонального тестування програмної системи «Inventory». URL: https://www.youtube.com/watch?v=8wMlUFts7NE
5.	Програмний код розробленої системи. URL: https://github.com/NurePosukanInna/apzkr-pzpi-21-6-posukan-inna

 
ДОДАТОК А
Діаграми
 
Рисунок А.1 – загальна Use-Case діаграма
 
Рисунок А.2 – Use-Case діаграма IoT частини
 
Рисунок А.3 – Use-Case діаграма мобільної частини

Рисунок А.4 – ER-діаграма бази даних
 
Рисунок А.5 – логічна діаграма бази даних

Рисунок А.6– діаграма компонентів клієнтської частини
 
Рисунок А.7 – діаграма станів клієнтської частин 
 
Рисунок А.8 - діаграма активності IoT частини

Рисунок А.9 - діаграма взаємодії IoT частини
 
Рисунок А.10– діаграма активності для мобільної частини
 
Рисунок А.11– діаграма активності для мобільної частини

ДОДАТОК Б
Код програми

Б.1 Код для шифрування паролю 

1.	public class Password
2.	{
3.	  public static string hashPassword(string password)
4.	  {
5.	     var sha = SHA256.Create();
6.	     var asByteArray = Encoding.Default.GetBytes(password);
7.	     var hashedPassword = sha.ComputeHash(asByteArray);
8.	     return Convert.ToBase64String(hashedPassword);
9.	  }}

Б.2 Задача автоматизації

10.	public async Task<int?> CalculateOrderQuantity(int productId)
11.	{
12.	   var lastWeekStartDate = DateTime.UtcNow.Date.AddDays(-7);
13.	   var completedRequests = await _context.SupplierRequests
14.	      .Where(r => r.StoreProduct != null &&
15.	         r.StoreProduct.ProductId == productId &&
16.	         r.RequestStatus == "Completed" &&
17.	         r.RequestDate >= lastWeekStartDate &&
18.	         r.RequestDate != null)
19.	      .OrderByDescending(r => r.RequestDate)
20.	      .Take(2).ToListAsync();
21.	  if (completedRequests.Count >= 2)
22.	  {
23.	     var averageQuantity = completedRequests
24.	     .Average(r => r.Quantity);
25.	     var orderQuantity = (int)Math.Ceiling((double)
26.	     (averageQuantity * 1.2)); 
27.	     return orderQuantity;
28.	  }
29.	  else
30.	  {
31.	     var storeProduct = await _context.StoreProducts
32.	       .FirstOrDefaultAsync(p => p.ProductId == productId);
33.	     if (storeProduct != null){
34.	         var orderQuantity = storeProduct.MinQuantity –
35.	         storeProduct.Quantity + 2;
36.	         return (int)orderQuantity;
37.	     }
38.	     else
39.	     {
40.	   return null;
41.	   }
42.	  }
43.	}

Б.3 Здійснення HTTP - запиту до серверної частини для  реєстрації користувача в системі.

44.	export const registerUser = async (userData) => {
45.	 try {
46.	   const response = await axios.post(
47.	   `${BASE_URL}/User/register`,userData
48.	    );
49.	    return response.data; 
50.	 } catch (error) {
51.	   throw error; 
52.	}
53.	};

Б.4 Відправлення з IoT пристрою на сервер PUT запитом

54.	HTTPClient http;
55.	http.begin(serverUrl);
56.	
57.	http.addHeader("Content-Type", "application/json");
58.	
59.	int httpResponseCode = http.PUT(jsonStr);
60.	
61.	if (httpResponseCode > 0) {
62.	  Serial.print("HTTP Response code: ");
63.	  Serial.println(httpResponseCode);
64.	} else {
65.	  Serial.print("Error code: ");
66.	  Serial.println(httpResponseCode);
67.	}
68.	http.end();
 
ДОДАТОК В
Інтерфейси програми

 
Рисунок В.1 – реєстрація користувача в системі

Рисунок В.2 – повідомлення про успішну реєстрацію
 
Рисунок В.3 – вхід в систему

Рисунок В.4 – повідомлення про успішний вхід в систему
 
Рисунок В.5 – панель управління

Рисунок В.6 – перегляд підписок
 
Рисунок В.7 – придбання підписки

Рисунок В.8 – додавання магазину
 
Рисунок В.9 – перегляд доданого магазину
 
Рисунок В.10 – додавання продукту до магазину
 
Рисунок В.11 – перегляд доданого продукту
 
Рисунок В.12 – оновлення продукту
    
Рисунок В.13 – таблиця зіпсований продуктів
 
Рисунок В.14 – продукти до пошуку
 
Рисунок В.15 – пошук в системі
 
Рисунок В.16 – додавання касира 
 
Рисунок В.17 – перегляд доданого касира
 
Рисунок В.18 – оновлення даних про робітника
 
Рисунок В.9 – вхід в систему під аккаунтом касира
 
Рисунок В.20 – обмежений вигляд меню для касира
 
Рисунок В.21 – доступні магазини для касира
 
Рисунок В.22 – продаж товару
 
Рисунок В.23 – інформація про продаж товару
 
Рисунок В.24 – змінена кількість  товарів після продажу 
 
Рисунок В.25 – сформована заявка постачальнику
 
Рисунок В.26 – оновлення статусу заявки постачальнику

Рисунок В.27 – перегляд зміненого замовлення постачальнику
 
Рисунок В.28 – перегляд продукту після прийому заявки
       
Рисунок В.29 – аналіз попиту
 
Рисунок В.30– аналітика продажів
 
Рисунок В.31 – зміна локалізації для сторінки магазини
 
Рисунок В.32 – зміна локалізації для сторінки панель управління
 
Рисунок В.33 – придбання стандартної підписки
 
Рисунок В.34 – вказання параметрів температури та вологості

Рисунок В.35 – відправлення на сервер значень температури та вологості
 
Рисунок В.36 – відправлення повідомлення про зміну температури на складі

Рисунок В.37 – вхід в систему
 
Рисунок В.38– перегляд магазинів

Рисунок В.39– відправлення повідомлення про низьку температуру на складі

Рисунок В.40 – перегляд продуктів в магазині

Рисунок В.41 – перегляд та оновлення продукту в магазині

Рисунок В.42 – перегляд запитів постачальнику

Рисунок В.43 – перегляд та оновлення запиту

Рисунок В.44 – зміна статусу 

Рисунок В.45 – встановлення дати доставки

Рисунок В.46 – перегляд профілю 

Рисунок В.47 – оновлення профілю 
 
ДОДАТОК Г
Перевірка на плагіат

Рисунок Г.1 – перевірка на плагіат
